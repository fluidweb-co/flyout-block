{"version":3,"file":"../inert.min.js","sources":["inert.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory() :\n  typeof define === 'function' && define.amd ? define('inert', factory) :\n  (factory());\n}(this, (function () { 'use strict';\n\n  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  /**\n   * This work is licensed under the W3C Software and Document License\n   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n   */\n\n  (function () {\n    // Return early if we're not running inside of the browser.\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    // Convenience function for converting NodeLists.\n    /** @type {typeof Array.prototype.slice} */\n    var slice = Array.prototype.slice;\n\n    /**\n     * IE has a non-standard name for \"matches\".\n     * @type {typeof Element.prototype.matches}\n     */\n    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n    /** @type {string} */\n    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\n\n    /**\n     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n     * attribute.\n     *\n     * Its main functions are:\n     *\n     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n     *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n     *   instance exists for each focusable node which has at least one inert root as an ancestor.\n     *\n     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n     *   attribute is removed from the root node). This is handled in the destructor, which calls the\n     *   `deregister` method on `InertManager` for each managed inert node.\n     */\n\n    var InertRoot = function () {\n      /**\n       * @param {!Element} rootElement The Element at the root of the inert subtree.\n       * @param {!InertManager} inertManager The global singleton InertManager object.\n       */\n      function InertRoot(rootElement, inertManager) {\n        _classCallCheck(this, InertRoot);\n\n        /** @type {!InertManager} */\n        this._inertManager = inertManager;\n\n        /** @type {!Element} */\n        this._rootElement = rootElement;\n\n        /**\n         * @type {!Set<!InertNode>}\n         * All managed focusable nodes in this InertRoot's subtree.\n         */\n        this._managedNodes = new Set();\n\n        // Make the subtree hidden from assistive technology\n        if (this._rootElement.hasAttribute('aria-hidden')) {\n          /** @type {?string} */\n          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n        } else {\n          this._savedAriaHidden = null;\n        }\n        this._rootElement.setAttribute('aria-hidden', 'true');\n\n        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n        this._makeSubtreeUnfocusable(this._rootElement);\n\n        // Watch for:\n        // - any additions in the subtree: make them unfocusable too\n        // - any removals from the subtree: remove them from this inert root's managed nodes\n        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n        //   element, make that node a managed node.\n        this._observer = new MutationObserver(this._onMutation.bind(this));\n        this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });\n      }\n\n      /**\n       * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n       * stored in this object and updates the state of all of the managed nodes.\n       */\n\n\n      _createClass(InertRoot, [{\n        key: 'destructor',\n        value: function destructor() {\n          this._observer.disconnect();\n\n          if (this._rootElement) {\n            if (this._savedAriaHidden !== null) {\n              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n            } else {\n              this._rootElement.removeAttribute('aria-hidden');\n            }\n          }\n\n          this._managedNodes.forEach(function (inertNode) {\n            this._unmanageNode(inertNode.node);\n          }, this);\n\n          // Note we cast the nulls to the ANY type here because:\n          // 1) We want the class properties to be declared as non-null, or else we\n          //    need even more casts throughout this code. All bets are off if an\n          //    instance has been destroyed and a method is called.\n          // 2) We don't want to cast \"this\", because we want type-aware optimizations\n          //    to know which properties we're setting.\n          this._observer = /** @type {?} */null;\n          this._rootElement = /** @type {?} */null;\n          this._managedNodes = /** @type {?} */null;\n          this._inertManager = /** @type {?} */null;\n        }\n\n        /**\n         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n         */\n\n      }, {\n        key: '_makeSubtreeUnfocusable',\n\n\n        /**\n         * @param {!Node} startNode\n         */\n        value: function _makeSubtreeUnfocusable(startNode) {\n          var _this2 = this;\n\n          composedTreeWalk(startNode, function (node) {\n            return _this2._visitNode(node);\n          });\n\n          var activeElement = document.activeElement;\n\n          if (!document.body.contains(startNode)) {\n            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n            var node = startNode;\n            /** @type {!ShadowRoot|undefined} */\n            var root = undefined;\n            while (node) {\n              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                root = /** @type {!ShadowRoot} */node;\n                break;\n              }\n              node = node.parentNode;\n            }\n            if (root) {\n              activeElement = root.activeElement;\n            }\n          }\n          if (startNode.contains(activeElement)) {\n            activeElement.blur();\n            // In IE11, if an element is already focused, and then set to tabindex=-1\n            // calling blur() will not actually move the focus.\n            // To work around this we call focus() on the body instead.\n            if (activeElement === document.activeElement) {\n              document.body.focus();\n            }\n          }\n        }\n\n        /**\n         * @param {!Node} node\n         */\n\n      }, {\n        key: '_visitNode',\n        value: function _visitNode(node) {\n          if (node.nodeType !== Node.ELEMENT_NODE) {\n            return;\n          }\n          var element = /** @type {!Element} */node;\n\n          // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n          if (element !== this._rootElement && element.hasAttribute('inert')) {\n            this._adoptInertRoot(element);\n          }\n\n          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n            this._manageNode(element);\n          }\n        }\n\n        /**\n         * Register the given node with this InertRoot and with InertManager.\n         * @param {!Node} node\n         */\n\n      }, {\n        key: '_manageNode',\n        value: function _manageNode(node) {\n          var inertNode = this._inertManager.register(node, this);\n          this._managedNodes.add(inertNode);\n        }\n\n        /**\n         * Unregister the given node with this InertRoot and with InertManager.\n         * @param {!Node} node\n         */\n\n      }, {\n        key: '_unmanageNode',\n        value: function _unmanageNode(node) {\n          var inertNode = this._inertManager.deregister(node, this);\n          if (inertNode) {\n            this._managedNodes['delete'](inertNode);\n          }\n        }\n\n        /**\n         * Unregister the entire subtree starting at `startNode`.\n         * @param {!Node} startNode\n         */\n\n      }, {\n        key: '_unmanageSubtree',\n        value: function _unmanageSubtree(startNode) {\n          var _this3 = this;\n\n          composedTreeWalk(startNode, function (node) {\n            return _this3._unmanageNode(node);\n          });\n        }\n\n        /**\n         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n         * @param {!Element} node\n         */\n\n      }, {\n        key: '_adoptInertRoot',\n        value: function _adoptInertRoot(node) {\n          var inertSubroot = this._inertManager.getInertRoot(node);\n\n          // During initialisation this inert root may not have been registered yet,\n          // so register it now if need be.\n          if (!inertSubroot) {\n            this._inertManager.setInert(node, true);\n            inertSubroot = this._inertManager.getInertRoot(node);\n          }\n\n          inertSubroot.managedNodes.forEach(function (savedInertNode) {\n            this._manageNode(savedInertNode.node);\n          }, this);\n        }\n\n        /**\n         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n         * @param {!Array<!MutationRecord>} records\n         * @param {!MutationObserver} self\n         */\n\n      }, {\n        key: '_onMutation',\n        value: function _onMutation(records, self) {\n          records.forEach(function (record) {\n            var target = /** @type {!Element} */record.target;\n            if (record.type === 'childList') {\n              // Manage added nodes\n              slice.call(record.addedNodes).forEach(function (node) {\n                this._makeSubtreeUnfocusable(node);\n              }, this);\n\n              // Un-manage removed nodes\n              slice.call(record.removedNodes).forEach(function (node) {\n                this._unmanageSubtree(node);\n              }, this);\n            } else if (record.type === 'attributes') {\n              if (record.attributeName === 'tabindex') {\n                // Re-initialise inert node if tabindex changes\n                this._manageNode(target);\n              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {\n                // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n                // already managed nodes from this inert subroot.\n                this._adoptInertRoot(target);\n                var inertSubroot = this._inertManager.getInertRoot(target);\n                this._managedNodes.forEach(function (managedNode) {\n                  if (target.contains(managedNode.node)) {\n                    inertSubroot._manageNode(managedNode.node);\n                  }\n                });\n              }\n            }\n          }, this);\n        }\n      }, {\n        key: 'managedNodes',\n        get: function get() {\n          return new Set(this._managedNodes);\n        }\n\n        /** @return {boolean} */\n\n      }, {\n        key: 'hasSavedAriaHidden',\n        get: function get() {\n          return this._savedAriaHidden !== null;\n        }\n\n        /** @param {?string} ariaHidden */\n\n      }, {\n        key: 'savedAriaHidden',\n        set: function set(ariaHidden) {\n          this._savedAriaHidden = ariaHidden;\n        }\n\n        /** @return {?string} */\n        ,\n        get: function get() {\n          return this._savedAriaHidden;\n        }\n      }]);\n\n      return InertRoot;\n    }();\n\n    /**\n     * `InertNode` initialises and manages a single inert node.\n     * A node is inert if it is a descendant of one or more inert root elements.\n     *\n     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n     * is intrinsically focusable or not.\n     *\n     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n     * or removes the `tabindex` attribute if the element is intrinsically focusable.\n     */\n\n\n    var InertNode = function () {\n      /**\n       * @param {!Node} node A focusable element to be made inert.\n       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n       */\n      function InertNode(node, inertRoot) {\n        _classCallCheck(this, InertNode);\n\n        /** @type {!Node} */\n        this._node = node;\n\n        /** @type {boolean} */\n        this._overrodeFocusMethod = false;\n\n        /**\n         * @type {!Set<!InertRoot>} The set of descendant inert roots.\n         *    If and only if this set becomes empty, this node is no longer inert.\n         */\n        this._inertRoots = new Set([inertRoot]);\n\n        /** @type {?number} */\n        this._savedTabIndex = null;\n\n        /** @type {boolean} */\n        this._destroyed = false;\n\n        // Save any prior tabindex info and make this node untabbable\n        this.ensureUntabbable();\n      }\n\n      /**\n       * Call this whenever this object is about to become obsolete.\n       * This makes the managed node focusable again and deletes all of the previously stored state.\n       */\n\n\n      _createClass(InertNode, [{\n        key: 'destructor',\n        value: function destructor() {\n          this._throwIfDestroyed();\n\n          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n            var element = /** @type {!Element} */this._node;\n            if (this._savedTabIndex !== null) {\n              element.setAttribute('tabindex', this._savedTabIndex);\n            } else {\n              element.removeAttribute('tabindex');\n            }\n\n            // Use `delete` to restore native focus method.\n            if (this._overrodeFocusMethod) {\n              delete element.focus;\n            }\n          }\n\n          // See note in InertRoot.destructor for why we cast these nulls to ANY.\n          this._node = /** @type {?} */null;\n          this._inertRoots = /** @type {?} */null;\n          this._destroyed = true;\n        }\n\n        /**\n         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n         * If the object has been destroyed, any attempt to access it will cause an exception.\n         */\n\n      }, {\n        key: '_throwIfDestroyed',\n\n\n        /**\n         * Throw if user tries to access destroyed InertNode.\n         */\n        value: function _throwIfDestroyed() {\n          if (this.destroyed) {\n            throw new Error('Trying to access destroyed InertNode');\n          }\n        }\n\n        /** @return {boolean} */\n\n      }, {\n        key: 'ensureUntabbable',\n\n\n        /** Save the existing tabindex value and make the node untabbable and unfocusable */\n        value: function ensureUntabbable() {\n          if (this.node.nodeType !== Node.ELEMENT_NODE) {\n            return;\n          }\n          var element = /** @type {!Element} */this.node;\n          if (matches.call(element, _focusableElementsString)) {\n            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {\n              return;\n            }\n\n            if (element.hasAttribute('tabindex')) {\n              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n            }\n            element.setAttribute('tabindex', '-1');\n            if (element.nodeType === Node.ELEMENT_NODE) {\n              element.focus = function () {};\n              this._overrodeFocusMethod = true;\n            }\n          } else if (element.hasAttribute('tabindex')) {\n            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n            element.removeAttribute('tabindex');\n          }\n        }\n\n        /**\n         * Add another inert root to this inert node's set of managing inert roots.\n         * @param {!InertRoot} inertRoot\n         */\n\n      }, {\n        key: 'addInertRoot',\n        value: function addInertRoot(inertRoot) {\n          this._throwIfDestroyed();\n          this._inertRoots.add(inertRoot);\n        }\n\n        /**\n         * Remove the given inert root from this inert node's set of managing inert roots.\n         * If the set of managing inert roots becomes empty, this node is no longer inert,\n         * so the object should be destroyed.\n         * @param {!InertRoot} inertRoot\n         */\n\n      }, {\n        key: 'removeInertRoot',\n        value: function removeInertRoot(inertRoot) {\n          this._throwIfDestroyed();\n          this._inertRoots['delete'](inertRoot);\n          if (this._inertRoots.size === 0) {\n            this.destructor();\n          }\n        }\n      }, {\n        key: 'destroyed',\n        get: function get() {\n          return (/** @type {!InertNode} */this._destroyed\n          );\n        }\n      }, {\n        key: 'hasSavedTabIndex',\n        get: function get() {\n          return this._savedTabIndex !== null;\n        }\n\n        /** @return {!Node} */\n\n      }, {\n        key: 'node',\n        get: function get() {\n          this._throwIfDestroyed();\n          return this._node;\n        }\n\n        /** @param {?number} tabIndex */\n\n      }, {\n        key: 'savedTabIndex',\n        set: function set(tabIndex) {\n          this._throwIfDestroyed();\n          this._savedTabIndex = tabIndex;\n        }\n\n        /** @return {?number} */\n        ,\n        get: function get() {\n          this._throwIfDestroyed();\n          return this._savedTabIndex;\n        }\n      }]);\n\n      return InertNode;\n    }();\n\n    /**\n     * InertManager is a per-document singleton object which manages all inert roots and nodes.\n     *\n     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n     * is created for each such node, via the `_managedNodes` map.\n     */\n\n\n    var InertManager = function () {\n      /**\n       * @param {!Document} document\n       */\n      function InertManager(document) {\n        _classCallCheck(this, InertManager);\n\n        if (!document) {\n          throw new Error('Missing required argument; InertManager needs to wrap a document.');\n        }\n\n        /** @type {!Document} */\n        this._document = document;\n\n        /**\n         * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n         * @type {!Map<!Node, !InertNode>}\n         */\n        this._managedNodes = new Map();\n\n        /**\n         * All inert roots known to this InertManager. In a map to allow looking up by Node.\n         * @type {!Map<!Node, !InertRoot>}\n         */\n        this._inertRoots = new Map();\n\n        /**\n         * Observer for mutations on `document.body`.\n         * @type {!MutationObserver}\n         */\n        this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n        // Add inert style.\n        addInertStyle(document.head || document.body || document.documentElement);\n\n        // Wait for document to be loaded.\n        if (document.readyState === 'loading') {\n          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n        } else {\n          this._onDocumentLoaded();\n        }\n      }\n\n      /**\n       * Set whether the given element should be an inert root or not.\n       * @param {!Element} root\n       * @param {boolean} inert\n       */\n\n\n      _createClass(InertManager, [{\n        key: 'setInert',\n        value: function setInert(root, inert) {\n          if (inert) {\n            if (this._inertRoots.has(root)) {\n              // element is already inert\n              return;\n            }\n\n            var inertRoot = new InertRoot(root, this);\n            root.setAttribute('inert', '');\n            this._inertRoots.set(root, inertRoot);\n            // If not contained in the document, it must be in a shadowRoot.\n            // Ensure inert styles are added there.\n            if (!this._document.body.contains(root)) {\n              var parent = root.parentNode;\n              while (parent) {\n                if (parent.nodeType === 11) {\n                  addInertStyle(parent);\n                }\n                parent = parent.parentNode;\n              }\n            }\n          } else {\n            if (!this._inertRoots.has(root)) {\n              // element is already non-inert\n              return;\n            }\n\n            var _inertRoot = this._inertRoots.get(root);\n            _inertRoot.destructor();\n            this._inertRoots['delete'](root);\n            root.removeAttribute('inert');\n          }\n        }\n\n        /**\n         * Get the InertRoot object corresponding to the given inert root element, if any.\n         * @param {!Node} element\n         * @return {!InertRoot|undefined}\n         */\n\n      }, {\n        key: 'getInertRoot',\n        value: function getInertRoot(element) {\n          return this._inertRoots.get(element);\n        }\n\n        /**\n         * Register the given InertRoot as managing the given node.\n         * In the case where the node has a previously existing inert root, this inert root will\n         * be added to its set of inert roots.\n         * @param {!Node} node\n         * @param {!InertRoot} inertRoot\n         * @return {!InertNode} inertNode\n         */\n\n      }, {\n        key: 'register',\n        value: function register(node, inertRoot) {\n          var inertNode = this._managedNodes.get(node);\n          if (inertNode !== undefined) {\n            // node was already in an inert subtree\n            inertNode.addInertRoot(inertRoot);\n          } else {\n            inertNode = new InertNode(node, inertRoot);\n          }\n\n          this._managedNodes.set(node, inertNode);\n\n          return inertNode;\n        }\n\n        /**\n         * De-register the given InertRoot as managing the given inert node.\n         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n         * node from the InertManager's set of managed nodes if it is destroyed.\n         * If the node is not currently managed, this is essentially a no-op.\n         * @param {!Node} node\n         * @param {!InertRoot} inertRoot\n         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n         */\n\n      }, {\n        key: 'deregister',\n        value: function deregister(node, inertRoot) {\n          var inertNode = this._managedNodes.get(node);\n          if (!inertNode) {\n            return null;\n          }\n\n          inertNode.removeInertRoot(inertRoot);\n          if (inertNode.destroyed) {\n            this._managedNodes['delete'](node);\n          }\n\n          return inertNode;\n        }\n\n        /**\n         * Callback used when document has finished loading.\n         */\n\n      }, {\n        key: '_onDocumentLoaded',\n        value: function _onDocumentLoaded() {\n          // Find all inert roots in document and make them actually inert.\n          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n          inertElements.forEach(function (inertElement) {\n            this.setInert(inertElement, true);\n          }, this);\n\n          // Comment this out to use programmatic API only.\n          this._observer.observe(this._document.body || this._document.documentElement, { attributes: true, subtree: true, childList: true });\n        }\n\n        /**\n         * Callback used when mutation observer detects attribute changes.\n         * @param {!Array<!MutationRecord>} records\n         * @param {!MutationObserver} self\n         */\n\n      }, {\n        key: '_watchForInert',\n        value: function _watchForInert(records, self) {\n          var _this = this;\n          records.forEach(function (record) {\n            switch (record.type) {\n              case 'childList':\n                slice.call(record.addedNodes).forEach(function (node) {\n                  if (node.nodeType !== Node.ELEMENT_NODE) {\n                    return;\n                  }\n                  var inertElements = slice.call(node.querySelectorAll('[inert]'));\n                  if (matches.call(node, '[inert]')) {\n                    inertElements.unshift(node);\n                  }\n                  inertElements.forEach(function (inertElement) {\n                    this.setInert(inertElement, true);\n                  }, _this);\n                }, _this);\n                break;\n              case 'attributes':\n                if (record.attributeName !== 'inert') {\n                  return;\n                }\n                var target = /** @type {!Element} */record.target;\n                var inert = target.hasAttribute('inert');\n                _this.setInert(target, inert);\n                break;\n            }\n          }, this);\n        }\n      }]);\n\n      return InertManager;\n    }();\n\n    /**\n     * Recursively walk the composed tree from |node|.\n     * @param {!Node} node\n     * @param {(function (!Element))=} callback Callback to be called for each element traversed,\n     *     before descending into child nodes.\n     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n     */\n\n\n    function composedTreeWalk(node, callback, shadowRootAncestor) {\n      if (node.nodeType == Node.ELEMENT_NODE) {\n        var element = /** @type {!Element} */node;\n        if (callback) {\n          callback(element);\n        }\n\n        // Descend into node:\n        // If it has a ShadowRoot, ignore all child elements - these will be picked\n        // up by the <content> or <shadow> elements. Descend straight into the\n        // ShadowRoot.\n        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;\n        if (shadowRoot) {\n          composedTreeWalk(shadowRoot, callback, shadowRoot);\n          return;\n        }\n\n        // If it is a <content> element, descend into distributed elements - these\n        // are elements from outside the shadow root which are rendered inside the\n        // shadow DOM.\n        if (element.localName == 'content') {\n          var content = /** @type {!HTMLContentElement} */element;\n          // Verifies if ShadowDom v0 is supported.\n          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];\n          for (var i = 0; i < distributedNodes.length; i++) {\n            composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n          }\n          return;\n        }\n\n        // If it is a <slot> element, descend into assigned nodes - these\n        // are elements from outside the shadow root which are rendered inside the\n        // shadow DOM.\n        if (element.localName == 'slot') {\n          var slot = /** @type {!HTMLSlotElement} */element;\n          // Verify if ShadowDom v1 is supported.\n          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({ flatten: true }) : [];\n          for (var _i = 0; _i < _distributedNodes.length; _i++) {\n            composedTreeWalk(_distributedNodes[_i], callback, shadowRootAncestor);\n          }\n          return;\n        }\n      }\n\n      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n      // element, nor a <shadow> element recurse normally.\n      var child = node.firstChild;\n      while (child != null) {\n        composedTreeWalk(child, callback, shadowRootAncestor);\n        child = child.nextSibling;\n      }\n    }\n\n    /**\n     * Adds a style element to the node containing the inert specific styles\n     * @param {!Node} node\n     */\n    function addInertStyle(node) {\n      if (node.querySelector('style#inert-style, link#inert-style')) {\n        return;\n      }\n      var style = document.createElement('style');\n      style.setAttribute('id', 'inert-style');\n      style.textContent = '\\n' + '[inert] {\\n' + '  pointer-events: none;\\n' + '  cursor: default;\\n' + '}\\n' + '\\n' + '[inert], [inert] * {\\n' + '  -webkit-user-select: none;\\n' + '  -moz-user-select: none;\\n' + '  -ms-user-select: none;\\n' + '  user-select: none;\\n' + '}\\n';\n      node.appendChild(style);\n    }\n\n    if (!Element.prototype.hasOwnProperty('inert')) {\n      /** @type {!InertManager} */\n      var inertManager = new InertManager(document);\n\n      Object.defineProperty(Element.prototype, 'inert', {\n        enumerable: true,\n        /** @this {!Element} */\n        get: function get() {\n          return this.hasAttribute('inert');\n        },\n        /** @this {!Element} */\n        set: function set(inert) {\n          inertManager.setInert(this, inert);\n        }\n      });\n    }\n  })();\n\n})));\n"],"names":["factory","exports","module","define","amd","slice","matches","_focusableElementsString","InertRoot","InertNode","inertManager","_createClass","Constructor","protoProps","staticProps","defineProperties","prototype","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_classCallCheck","instance","TypeError","rootElement","this","_inertManager","_rootElement","_managedNodes","Set","hasAttribute","_savedAriaHidden","getAttribute","setAttribute","_makeSubtreeUnfocusable","_observer","MutationObserver","_onMutation","bind","observe","attributes","childList","subtree","node","inertRoot","_node","_overrodeFocusMethod","_inertRoots","_savedTabIndex","_destroyed","ensureUntabbable","InertManager","document","Error","_document","Map","_watchForInert","addInertStyle","head","body","documentElement","readyState","addEventListener","_onDocumentLoaded","composedTreeWalk","callback","shadowRootAncestor","nodeType","Node","ELEMENT_NODE","element","shadowRoot","localName","content","distributedNodes","getDistributedNodes","slot","_distributedNodes","assignedNodes","flatten","_i","child","firstChild","nextSibling","style","querySelector","createElement","textContent","appendChild","window","Array","Element","msMatchesSelector","join","value","disconnect","removeAttribute","forEach","inertNode","_unmanageNode","startNode","_this2","activeElement","_visitNode","contains","root","undefined","DOCUMENT_FRAGMENT_NODE","parentNode","blur","focus","_adoptInertRoot","call","_manageNode","register","add","deregister","_this3","inertSubroot","getInertRoot","setInert","managedNodes","savedInertNode","records","self","record","type","addedNodes","removedNodes","_unmanageSubtree","attributeName","managedNode","get","set","ariaHidden","_throwIfDestroyed","destroyed","tabIndex","hasSavedTabIndex","size","destructor","inert","has","parent","addInertRoot","removeInertRoot","querySelectorAll","inertElement","_this","inertElements","unshift","hasOwnProperty"],"mappings":"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"}