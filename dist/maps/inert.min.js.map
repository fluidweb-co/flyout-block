{"version":3,"file":"../inert.min.js","sources":["inert.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory() :\n  typeof define === 'function' && define.amd ? define('inert', factory) :\n  (factory());\n}(this, (function () { 'use strict';\n\n  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  /**\n   * This work is licensed under the W3C Software and Document License\n   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n   */\n\n  (function () {\n    // Return early if we're not running inside of the browser.\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    // Convenience function for converting NodeLists.\n    /** @type {typeof Array.prototype.slice} */\n    var slice = Array.prototype.slice;\n\n    /**\n     * IE has a non-standard name for \"matches\".\n     * @type {typeof Element.prototype.matches}\n     */\n    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n    /** @type {string} */\n    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\n\n    /**\n     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n     * attribute.\n     *\n     * Its main functions are:\n     *\n     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n     *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n     *   instance exists for each focusable node which has at least one inert root as an ancestor.\n     *\n     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n     *   attribute is removed from the root node). This is handled in the destructor, which calls the\n     *   `deregister` method on `InertManager` for each managed inert node.\n     */\n\n    var InertRoot = function () {\n      /**\n       * @param {!Element} rootElement The Element at the root of the inert subtree.\n       * @param {!InertManager} inertManager The global singleton InertManager object.\n       */\n      function InertRoot(rootElement, inertManager) {\n        _classCallCheck(this, InertRoot);\n\n        /** @type {!InertManager} */\n        this._inertManager = inertManager;\n\n        /** @type {!Element} */\n        this._rootElement = rootElement;\n\n        /**\n         * @type {!Set<!InertNode>}\n         * All managed focusable nodes in this InertRoot's subtree.\n         */\n        this._managedNodes = new Set();\n\n        // Make the subtree hidden from assistive technology\n        if (this._rootElement.hasAttribute('aria-hidden')) {\n          /** @type {?string} */\n          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n        } else {\n          this._savedAriaHidden = null;\n        }\n        this._rootElement.setAttribute('aria-hidden', 'true');\n\n        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n        this._makeSubtreeUnfocusable(this._rootElement);\n\n        // Watch for:\n        // - any additions in the subtree: make them unfocusable too\n        // - any removals from the subtree: remove them from this inert root's managed nodes\n        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n        //   element, make that node a managed node.\n        this._observer = new MutationObserver(this._onMutation.bind(this));\n        this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });\n      }\n\n      /**\n       * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n       * stored in this object and updates the state of all of the managed nodes.\n       */\n\n\n      _createClass(InertRoot, [{\n        key: 'destructor',\n        value: function destructor() {\n          this._observer.disconnect();\n\n          if (this._rootElement) {\n            if (this._savedAriaHidden !== null) {\n              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n            } else {\n              this._rootElement.removeAttribute('aria-hidden');\n            }\n          }\n\n          this._managedNodes.forEach(function (inertNode) {\n            this._unmanageNode(inertNode.node);\n          }, this);\n\n          // Note we cast the nulls to the ANY type here because:\n          // 1) We want the class properties to be declared as non-null, or else we\n          //    need even more casts throughout this code. All bets are off if an\n          //    instance has been destroyed and a method is called.\n          // 2) We don't want to cast \"this\", because we want type-aware optimizations\n          //    to know which properties we're setting.\n          this._observer = /** @type {?} */null;\n          this._rootElement = /** @type {?} */null;\n          this._managedNodes = /** @type {?} */null;\n          this._inertManager = /** @type {?} */null;\n        }\n\n        /**\n         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n         */\n\n      }, {\n        key: '_makeSubtreeUnfocusable',\n\n\n        /**\n         * @param {!Node} startNode\n         */\n        value: function _makeSubtreeUnfocusable(startNode) {\n          var _this2 = this;\n\n          composedTreeWalk(startNode, function (node) {\n            return _this2._visitNode(node);\n          });\n\n          var activeElement = document.activeElement;\n\n          if (!document.body.contains(startNode)) {\n            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n            var node = startNode;\n            /** @type {!ShadowRoot|undefined} */\n            var root = undefined;\n            while (node) {\n              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                root = /** @type {!ShadowRoot} */node;\n                break;\n              }\n              node = node.parentNode;\n            }\n            if (root) {\n              activeElement = root.activeElement;\n            }\n          }\n          if (startNode.contains(activeElement)) {\n            activeElement.blur();\n            // In IE11, if an element is already focused, and then set to tabindex=-1\n            // calling blur() will not actually move the focus.\n            // To work around this we call focus() on the body instead.\n            if (activeElement === document.activeElement) {\n              document.body.focus();\n            }\n          }\n        }\n\n        /**\n         * @param {!Node} node\n         */\n\n      }, {\n        key: '_visitNode',\n        value: function _visitNode(node) {\n          if (node.nodeType !== Node.ELEMENT_NODE) {\n            return;\n          }\n          var element = /** @type {!Element} */node;\n\n          // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n          if (element !== this._rootElement && element.hasAttribute('inert')) {\n            this._adoptInertRoot(element);\n          }\n\n          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n            this._manageNode(element);\n          }\n        }\n\n        /**\n         * Register the given node with this InertRoot and with InertManager.\n         * @param {!Node} node\n         */\n\n      }, {\n        key: '_manageNode',\n        value: function _manageNode(node) {\n          var inertNode = this._inertManager.register(node, this);\n          this._managedNodes.add(inertNode);\n        }\n\n        /**\n         * Unregister the given node with this InertRoot and with InertManager.\n         * @param {!Node} node\n         */\n\n      }, {\n        key: '_unmanageNode',\n        value: function _unmanageNode(node) {\n          var inertNode = this._inertManager.deregister(node, this);\n          if (inertNode) {\n            this._managedNodes['delete'](inertNode);\n          }\n        }\n\n        /**\n         * Unregister the entire subtree starting at `startNode`.\n         * @param {!Node} startNode\n         */\n\n      }, {\n        key: '_unmanageSubtree',\n        value: function _unmanageSubtree(startNode) {\n          var _this3 = this;\n\n          composedTreeWalk(startNode, function (node) {\n            return _this3._unmanageNode(node);\n          });\n        }\n\n        /**\n         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n         * @param {!Element} node\n         */\n\n      }, {\n        key: '_adoptInertRoot',\n        value: function _adoptInertRoot(node) {\n          var inertSubroot = this._inertManager.getInertRoot(node);\n\n          // During initialisation this inert root may not have been registered yet,\n          // so register it now if need be.\n          if (!inertSubroot) {\n            this._inertManager.setInert(node, true);\n            inertSubroot = this._inertManager.getInertRoot(node);\n          }\n\n          inertSubroot.managedNodes.forEach(function (savedInertNode) {\n            this._manageNode(savedInertNode.node);\n          }, this);\n        }\n\n        /**\n         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n         * @param {!Array<!MutationRecord>} records\n         * @param {!MutationObserver} self\n         */\n\n      }, {\n        key: '_onMutation',\n        value: function _onMutation(records, self) {\n          records.forEach(function (record) {\n            var target = /** @type {!Element} */record.target;\n            if (record.type === 'childList') {\n              // Manage added nodes\n              slice.call(record.addedNodes).forEach(function (node) {\n                this._makeSubtreeUnfocusable(node);\n              }, this);\n\n              // Un-manage removed nodes\n              slice.call(record.removedNodes).forEach(function (node) {\n                this._unmanageSubtree(node);\n              }, this);\n            } else if (record.type === 'attributes') {\n              if (record.attributeName === 'tabindex') {\n                // Re-initialise inert node if tabindex changes\n                this._manageNode(target);\n              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {\n                // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n                // already managed nodes from this inert subroot.\n                this._adoptInertRoot(target);\n                var inertSubroot = this._inertManager.getInertRoot(target);\n                this._managedNodes.forEach(function (managedNode) {\n                  if (target.contains(managedNode.node)) {\n                    inertSubroot._manageNode(managedNode.node);\n                  }\n                });\n              }\n            }\n          }, this);\n        }\n      }, {\n        key: 'managedNodes',\n        get: function get() {\n          return new Set(this._managedNodes);\n        }\n\n        /** @return {boolean} */\n\n      }, {\n        key: 'hasSavedAriaHidden',\n        get: function get() {\n          return this._savedAriaHidden !== null;\n        }\n\n        /** @param {?string} ariaHidden */\n\n      }, {\n        key: 'savedAriaHidden',\n        set: function set(ariaHidden) {\n          this._savedAriaHidden = ariaHidden;\n        }\n\n        /** @return {?string} */\n        ,\n        get: function get() {\n          return this._savedAriaHidden;\n        }\n      }]);\n\n      return InertRoot;\n    }();\n\n    /**\n     * `InertNode` initialises and manages a single inert node.\n     * A node is inert if it is a descendant of one or more inert root elements.\n     *\n     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n     * is intrinsically focusable or not.\n     *\n     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n     * or removes the `tabindex` attribute if the element is intrinsically focusable.\n     */\n\n\n    var InertNode = function () {\n      /**\n       * @param {!Node} node A focusable element to be made inert.\n       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n       */\n      function InertNode(node, inertRoot) {\n        _classCallCheck(this, InertNode);\n\n        /** @type {!Node} */\n        this._node = node;\n\n        /** @type {boolean} */\n        this._overrodeFocusMethod = false;\n\n        /**\n         * @type {!Set<!InertRoot>} The set of descendant inert roots.\n         *    If and only if this set becomes empty, this node is no longer inert.\n         */\n        this._inertRoots = new Set([inertRoot]);\n\n        /** @type {?number} */\n        this._savedTabIndex = null;\n\n        /** @type {boolean} */\n        this._destroyed = false;\n\n        // Save any prior tabindex info and make this node untabbable\n        this.ensureUntabbable();\n      }\n\n      /**\n       * Call this whenever this object is about to become obsolete.\n       * This makes the managed node focusable again and deletes all of the previously stored state.\n       */\n\n\n      _createClass(InertNode, [{\n        key: 'destructor',\n        value: function destructor() {\n          this._throwIfDestroyed();\n\n          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n            var element = /** @type {!Element} */this._node;\n            if (this._savedTabIndex !== null) {\n              element.setAttribute('tabindex', this._savedTabIndex);\n            } else {\n              element.removeAttribute('tabindex');\n            }\n\n            // Use `delete` to restore native focus method.\n            if (this._overrodeFocusMethod) {\n              delete element.focus;\n            }\n          }\n\n          // See note in InertRoot.destructor for why we cast these nulls to ANY.\n          this._node = /** @type {?} */null;\n          this._inertRoots = /** @type {?} */null;\n          this._destroyed = true;\n        }\n\n        /**\n         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n         * If the object has been destroyed, any attempt to access it will cause an exception.\n         */\n\n      }, {\n        key: '_throwIfDestroyed',\n\n\n        /**\n         * Throw if user tries to access destroyed InertNode.\n         */\n        value: function _throwIfDestroyed() {\n          if (this.destroyed) {\n            throw new Error('Trying to access destroyed InertNode');\n          }\n        }\n\n        /** @return {boolean} */\n\n      }, {\n        key: 'ensureUntabbable',\n\n\n        /** Save the existing tabindex value and make the node untabbable and unfocusable */\n        value: function ensureUntabbable() {\n          if (this.node.nodeType !== Node.ELEMENT_NODE) {\n            return;\n          }\n          var element = /** @type {!Element} */this.node;\n          if (matches.call(element, _focusableElementsString)) {\n            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {\n              return;\n            }\n\n            if (element.hasAttribute('tabindex')) {\n              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n            }\n            element.setAttribute('tabindex', '-1');\n            if (element.nodeType === Node.ELEMENT_NODE) {\n              element.focus = function () {};\n              this._overrodeFocusMethod = true;\n            }\n          } else if (element.hasAttribute('tabindex')) {\n            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n            element.removeAttribute('tabindex');\n          }\n        }\n\n        /**\n         * Add another inert root to this inert node's set of managing inert roots.\n         * @param {!InertRoot} inertRoot\n         */\n\n      }, {\n        key: 'addInertRoot',\n        value: function addInertRoot(inertRoot) {\n          this._throwIfDestroyed();\n          this._inertRoots.add(inertRoot);\n        }\n\n        /**\n         * Remove the given inert root from this inert node's set of managing inert roots.\n         * If the set of managing inert roots becomes empty, this node is no longer inert,\n         * so the object should be destroyed.\n         * @param {!InertRoot} inertRoot\n         */\n\n      }, {\n        key: 'removeInertRoot',\n        value: function removeInertRoot(inertRoot) {\n          this._throwIfDestroyed();\n          this._inertRoots['delete'](inertRoot);\n          if (this._inertRoots.size === 0) {\n            this.destructor();\n          }\n        }\n      }, {\n        key: 'destroyed',\n        get: function get() {\n          return (/** @type {!InertNode} */this._destroyed\n          );\n        }\n      }, {\n        key: 'hasSavedTabIndex',\n        get: function get() {\n          return this._savedTabIndex !== null;\n        }\n\n        /** @return {!Node} */\n\n      }, {\n        key: 'node',\n        get: function get() {\n          this._throwIfDestroyed();\n          return this._node;\n        }\n\n        /** @param {?number} tabIndex */\n\n      }, {\n        key: 'savedTabIndex',\n        set: function set(tabIndex) {\n          this._throwIfDestroyed();\n          this._savedTabIndex = tabIndex;\n        }\n\n        /** @return {?number} */\n        ,\n        get: function get() {\n          this._throwIfDestroyed();\n          return this._savedTabIndex;\n        }\n      }]);\n\n      return InertNode;\n    }();\n\n    /**\n     * InertManager is a per-document singleton object which manages all inert roots and nodes.\n     *\n     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n     * is created for each such node, via the `_managedNodes` map.\n     */\n\n\n    var InertManager = function () {\n      /**\n       * @param {!Document} document\n       */\n      function InertManager(document) {\n        _classCallCheck(this, InertManager);\n\n        if (!document) {\n          throw new Error('Missing required argument; InertManager needs to wrap a document.');\n        }\n\n        /** @type {!Document} */\n        this._document = document;\n\n        /**\n         * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n         * @type {!Map<!Node, !InertNode>}\n         */\n        this._managedNodes = new Map();\n\n        /**\n         * All inert roots known to this InertManager. In a map to allow looking up by Node.\n         * @type {!Map<!Node, !InertRoot>}\n         */\n        this._inertRoots = new Map();\n\n        /**\n         * Observer for mutations on `document.body`.\n         * @type {!MutationObserver}\n         */\n        this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n        // Add inert style.\n        addInertStyle(document.head || document.body || document.documentElement);\n\n        // Wait for document to be loaded.\n        if (document.readyState === 'loading') {\n          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n        } else {\n          this._onDocumentLoaded();\n        }\n      }\n\n      /**\n       * Set whether the given element should be an inert root or not.\n       * @param {!Element} root\n       * @param {boolean} inert\n       */\n\n\n      _createClass(InertManager, [{\n        key: 'setInert',\n        value: function setInert(root, inert) {\n          if (inert) {\n            if (this._inertRoots.has(root)) {\n              // element is already inert\n              return;\n            }\n\n            var inertRoot = new InertRoot(root, this);\n            root.setAttribute('inert', '');\n            this._inertRoots.set(root, inertRoot);\n            // If not contained in the document, it must be in a shadowRoot.\n            // Ensure inert styles are added there.\n            if (!this._document.body.contains(root)) {\n              var parent = root.parentNode;\n              while (parent) {\n                if (parent.nodeType === 11) {\n                  addInertStyle(parent);\n                }\n                parent = parent.parentNode;\n              }\n            }\n          } else {\n            if (!this._inertRoots.has(root)) {\n              // element is already non-inert\n              return;\n            }\n\n            var _inertRoot = this._inertRoots.get(root);\n            _inertRoot.destructor();\n            this._inertRoots['delete'](root);\n            root.removeAttribute('inert');\n          }\n        }\n\n        /**\n         * Get the InertRoot object corresponding to the given inert root element, if any.\n         * @param {!Node} element\n         * @return {!InertRoot|undefined}\n         */\n\n      }, {\n        key: 'getInertRoot',\n        value: function getInertRoot(element) {\n          return this._inertRoots.get(element);\n        }\n\n        /**\n         * Register the given InertRoot as managing the given node.\n         * In the case where the node has a previously existing inert root, this inert root will\n         * be added to its set of inert roots.\n         * @param {!Node} node\n         * @param {!InertRoot} inertRoot\n         * @return {!InertNode} inertNode\n         */\n\n      }, {\n        key: 'register',\n        value: function register(node, inertRoot) {\n          var inertNode = this._managedNodes.get(node);\n          if (inertNode !== undefined) {\n            // node was already in an inert subtree\n            inertNode.addInertRoot(inertRoot);\n          } else {\n            inertNode = new InertNode(node, inertRoot);\n          }\n\n          this._managedNodes.set(node, inertNode);\n\n          return inertNode;\n        }\n\n        /**\n         * De-register the given InertRoot as managing the given inert node.\n         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n         * node from the InertManager's set of managed nodes if it is destroyed.\n         * If the node is not currently managed, this is essentially a no-op.\n         * @param {!Node} node\n         * @param {!InertRoot} inertRoot\n         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n         */\n\n      }, {\n        key: 'deregister',\n        value: function deregister(node, inertRoot) {\n          var inertNode = this._managedNodes.get(node);\n          if (!inertNode) {\n            return null;\n          }\n\n          inertNode.removeInertRoot(inertRoot);\n          if (inertNode.destroyed) {\n            this._managedNodes['delete'](node);\n          }\n\n          return inertNode;\n        }\n\n        /**\n         * Callback used when document has finished loading.\n         */\n\n      }, {\n        key: '_onDocumentLoaded',\n        value: function _onDocumentLoaded() {\n          // Find all inert roots in document and make them actually inert.\n          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n          inertElements.forEach(function (inertElement) {\n            this.setInert(inertElement, true);\n          }, this);\n\n          // Comment this out to use programmatic API only.\n          this._observer.observe(this._document.body || this._document.documentElement, { attributes: true, subtree: true, childList: true });\n        }\n\n        /**\n         * Callback used when mutation observer detects attribute changes.\n         * @param {!Array<!MutationRecord>} records\n         * @param {!MutationObserver} self\n         */\n\n      }, {\n        key: '_watchForInert',\n        value: function _watchForInert(records, self) {\n          var _this = this;\n          records.forEach(function (record) {\n            switch (record.type) {\n              case 'childList':\n                slice.call(record.addedNodes).forEach(function (node) {\n                  if (node.nodeType !== Node.ELEMENT_NODE) {\n                    return;\n                  }\n                  var inertElements = slice.call(node.querySelectorAll('[inert]'));\n                  if (matches.call(node, '[inert]')) {\n                    inertElements.unshift(node);\n                  }\n                  inertElements.forEach(function (inertElement) {\n                    this.setInert(inertElement, true);\n                  }, _this);\n                }, _this);\n                break;\n              case 'attributes':\n                if (record.attributeName !== 'inert') {\n                  return;\n                }\n                var target = /** @type {!Element} */record.target;\n                var inert = target.hasAttribute('inert');\n                _this.setInert(target, inert);\n                break;\n            }\n          }, this);\n        }\n      }]);\n\n      return InertManager;\n    }();\n\n    /**\n     * Recursively walk the composed tree from |node|.\n     * @param {!Node} node\n     * @param {(function (!Element))=} callback Callback to be called for each element traversed,\n     *     before descending into child nodes.\n     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n     */\n\n\n    function composedTreeWalk(node, callback, shadowRootAncestor) {\n      if (node.nodeType == Node.ELEMENT_NODE) {\n        var element = /** @type {!Element} */node;\n        if (callback) {\n          callback(element);\n        }\n\n        // Descend into node:\n        // If it has a ShadowRoot, ignore all child elements - these will be picked\n        // up by the <content> or <shadow> elements. Descend straight into the\n        // ShadowRoot.\n        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;\n        if (shadowRoot) {\n          composedTreeWalk(shadowRoot, callback, shadowRoot);\n          return;\n        }\n\n        // If it is a <content> element, descend into distributed elements - these\n        // are elements from outside the shadow root which are rendered inside the\n        // shadow DOM.\n        if (element.localName == 'content') {\n          var content = /** @type {!HTMLContentElement} */element;\n          // Verifies if ShadowDom v0 is supported.\n          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];\n          for (var i = 0; i < distributedNodes.length; i++) {\n            composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n          }\n          return;\n        }\n\n        // If it is a <slot> element, descend into assigned nodes - these\n        // are elements from outside the shadow root which are rendered inside the\n        // shadow DOM.\n        if (element.localName == 'slot') {\n          var slot = /** @type {!HTMLSlotElement} */element;\n          // Verify if ShadowDom v1 is supported.\n          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({ flatten: true }) : [];\n          for (var _i = 0; _i < _distributedNodes.length; _i++) {\n            composedTreeWalk(_distributedNodes[_i], callback, shadowRootAncestor);\n          }\n          return;\n        }\n      }\n\n      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n      // element, nor a <shadow> element recurse normally.\n      var child = node.firstChild;\n      while (child != null) {\n        composedTreeWalk(child, callback, shadowRootAncestor);\n        child = child.nextSibling;\n      }\n    }\n\n    /**\n     * Adds a style element to the node containing the inert specific styles\n     * @param {!Node} node\n     */\n    function addInertStyle(node) {\n      if (node.querySelector('style#inert-style, link#inert-style')) {\n        return;\n      }\n      var style = document.createElement('style');\n      style.setAttribute('id', 'inert-style');\n      style.textContent = '\\n' + '[inert] {\\n' + '  pointer-events: none;\\n' + '  cursor: default;\\n' + '}\\n' + '\\n' + '[inert], [inert] * {\\n' + '  -webkit-user-select: none;\\n' + '  -moz-user-select: none;\\n' + '  -ms-user-select: none;\\n' + '  user-select: none;\\n' + '}\\n';\n      node.appendChild(style);\n    }\n\n    if (!Element.prototype.hasOwnProperty('inert')) {\n      /** @type {!InertManager} */\n      var inertManager = new InertManager(document);\n\n      Object.defineProperty(Element.prototype, 'inert', {\n        enumerable: true,\n        /** @this {!Element} */\n        get: function get() {\n          return this.hasAttribute('inert');\n        },\n        /** @this {!Element} */\n        set: function set(inert) {\n          inertManager.setInert(this, inert);\n        }\n      });\n    }\n  })();\n\n})));\n"],"names":["factory","exports","module","define","amd","slice","matches","_focusableElementsString","InertRoot","InertNode","inertManager","_createClass","Constructor","protoProps","staticProps","defineProperties","prototype","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_classCallCheck","instance","TypeError","rootElement","this","_inertManager","_rootElement","_managedNodes","Set","hasAttribute","_savedAriaHidden","getAttribute","setAttribute","_makeSubtreeUnfocusable","_observer","MutationObserver","_onMutation","bind","observe","attributes","childList","subtree","node","inertRoot","_node","_overrodeFocusMethod","_inertRoots","_savedTabIndex","_destroyed","ensureUntabbable","InertManager","document","Error","_document","Map","_watchForInert","addInertStyle","head","body","documentElement","readyState","addEventListener","_onDocumentLoaded","composedTreeWalk","callback","shadowRootAncestor","nodeType","Node","ELEMENT_NODE","element","shadowRoot","localName","distributedNodes","getDistributedNodes","_distributedNodes","assignedNodes","flatten","_i","child","firstChild","nextSibling","style","querySelector","createElement","textContent","appendChild","window","Array","Element","msMatchesSelector","join","value","disconnect","removeAttribute","forEach","inertNode","_unmanageNode","startNode","_this2","_visitNode","activeElement","contains","root","undefined","DOCUMENT_FRAGMENT_NODE","parentNode","blur","focus","_adoptInertRoot","call","_manageNode","register","add","deregister","_this3","inertSubroot","getInertRoot","setInert","managedNodes","savedInertNode","records","self","record","type","addedNodes","removedNodes","_unmanageSubtree","attributeName","managedNode","get","set","ariaHidden","_throwIfDestroyed","destroyed","tabIndex","hasSavedTabIndex","size","destructor","inert","has","parent","addInertRoot","removeInertRoot","querySelectorAll","inertElement","_this","inertElements","unshift","hasOwnProperty"],"mappings":"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"}